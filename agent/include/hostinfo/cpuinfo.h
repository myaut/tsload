
/*
    This file is part of TSLoad.
    Copyright 2013-2014, Sergey Klyaus, ITMO University

    TSLoad is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    TSLoad is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with TSLoad.  If not, see <http://www.gnu.org/licenses/>.    
*/  



#ifndef CPUINFO_H_
#define CPUINFO_H_

#include <tsload/defs.h>

#include <tsload/list.h>
#include <tsload/cpumask.h>

#include <tsload/obj/obj.h>

#include <hostinfo/hiobject.h>

/**
 * @module CPUInfo
 * 
 * CPUInfo collects information on CPU-Memory subsystem, and builds
 * hierarchy which consists of following objects:
 * 
 *    * **Node** - on NUMA systems - collection of processors and memory 		\
 *                 where all processors may uniformly access memory.		    \
 *                 On UMA systems there is only single root Node
 *    * **Chip** - single processor package
 *    * **Core** - single processor core
 *    * **Strand** - hardware thread. Minimum CPU object capable of running     \
 *                 software thread
 *    * **Cache** - in-CPU memory. Each cache subdevice has its own object in   \
 *                 CPUInfo hierarchy
 * 
 * CPUInfo is purely hierarchial: Nodes -> Chip -> Core -> Strand. Cache devices
 * may be bound to Core or to Chip objects.
 * 
 * Each object has corresponding structure which contains its properties and
 * `hi_cpu_objtype_t` value, see following table:
 * 
 * ---
 * __Type__ | **structure** | `hi_cpu_objtype_t` | **Naming schema**
 * Node | `hi_cpu_node_t` | `HI_CPU_NODE` | node:NODEID
 * Chip | `hi_cpu_chip_t` | `HI_CPU_CHIP` | chip:CHIPID
 * Core | (not used) | `HI_CPU_CORE` | core:CHIPID:COREID
 * Strand | (not used) | `HI_CPU_STRAND` | strand:CHIPID:COREID:STRANDID
 * Cache | `hi_cpu_cache_t` | `HI_CPU_CACHE` | cache:LEVEL:CACHEID where LEVEL is l1, l2, l3 or tlb
 * ---
 * 
 * 
 */

#define 	HI_CPU_ANY			-1
#define 	HI_CPU_UNUSED		-2

/**
 * Generates ID of the cache
 */
#define HI_CPU_CACHEID(level, type)			\
	(level == HI_CPU_CACHE_TLB_LEVEL)		\
		? type								\
		: (level << 2 | type)

#define HI_CPU_CACHE_TLB_LEVEL		-1

typedef enum {
	HI_CPU_CACHE_UNIFIED,
	HI_CPU_CACHE_DATA,
	HI_CPU_CACHE_INSTRUCTION,
} hi_cpu_cache_type_t;

typedef enum {
	HI_CPU_NODE,
	HI_CPU_CHIP,
	HI_CPU_CORE,
	HI_CPU_STRAND,
	HI_CPU_CACHE
} hi_cpu_objtype_t;

typedef struct {
	uint32_t nodes;

	uint32_t mem_total;
	uint32_t mem_free;
} hi_cpu_stat_t;

/**
 * Descriptor of __Node__
 * 
 * @member cm_mem_total Total amount of memory of this node
 * @member cm_mem_free Free memory of this node (DEPRECATED)
 */
typedef struct {
	uint64_t cm_mem_total;
	uint64_t cm_mem_free;
} hi_cpu_node_t;

/**
 * Descriptor of __Chip__
 * 
 * @member cp_name Stock name of CPU chip 
 * @member cp_freq CPU frequency in MHz
 */
typedef struct {
	AUTOSTRING char* cp_name;
	uint64_t cp_freq;
} hi_cpu_chip_t;

typedef struct {
	int unused;
} hi_cpu_core_t;

typedef struct {
	int unused;
} hi_cpu_strand_t;

/**
 * Descriptor of __Cache__
 * 
 * @note TLB units also considered as cache objects, but this information 	\
 *       is rarely provided by OS (Solaris is best).
 * 
 * @member c_level level of cache. For TLB units it is set to `HI_CPU_CACHE_TLB_LEVEL`
 * @member c_type what information can keep this cache: data, instructions or both
 * @member c_size size of cache in bytes
 * @member c_associativity associativity of cache
 * @member c_unit_size.line size of cache line for memory cache
 * @member c_unit_size.page up to four page sizes this TLB unit may keep
 */
typedef struct {
	int 		   		c_level;
	hi_cpu_cache_type_t c_type;
	uint32_t	   		c_size;
	int 				c_associativity;
	union {
		int				line;
		long			page[4];
	} c_unit_size;
} hi_cpu_cache_t;

/**
 * Main CPUInfo descriptor
 * 
 * Each object as `id` which is unique across all objects of that `type` (except for caches).
 * 
 * Most of object ids are generated by HostInfo, but for **Strand** objects they are 
 * taken from operating system, so they may be reused in various API calls like CPU mask 
 * creation.
 * 
 * @member hdr HIObject header
 * @member c_cpu_name name of CPU object (same as `hdr.name`)
 * @member id object id
 * @member type object type
 * @member node for Nodes - descriptor of type `hi_cpu_node_t`
 * @member chip for Chips - descriptor of type `hi_cpu_chip_t`
 * @member cache for Caches - descriptor of type `hi_cpu_cache_t`
 */
typedef struct hi_cpu_object {
	hi_object_header_t		hdr;
#define c_cpu_name			hdr.name
	
	int 					id;
	hi_cpu_objtype_t 		type;

	union {
		hi_cpu_node_t node;
		hi_cpu_chip_t chip;
		hi_cpu_core_t core;
		hi_cpu_strand_t strand;
		hi_cpu_cache_t cache;
	};
} hi_cpu_object_t;

/**
 * Conversion macros
 */
#define HI_CPU_FROM_OBJ(object)		((hi_cpu_object_t*) (object))
#define HI_CPU_TO_OBJ(object)		((hi_object_t*) (object))
#define HI_CPU_PARENT_OBJ(object)	object->hdr.node.parent
#define HI_CPU_PARENT(object)		HI_CPU_FROM_OBJ(HI_CPU_PARENT_OBJ(object))

PLATAPI int hi_cpu_probe(void);
void hi_cpu_dtor(hi_object_t* object);
int hi_cpu_init(void);
void hi_cpu_fini(void);

hi_cpu_object_t* hi_cpu_object_create(hi_cpu_object_t* parent, hi_cpu_objtype_t type, int id);
void hi_cpu_object_add(hi_cpu_object_t* object);

void hi_cpu_set_chip_name(hi_cpu_object_t* chip, const char* name);

/**
 * Attaches/detaches CPU objects
 * 
 * @see hi_obj_attach
 * @see hi_obj_detach
 */
STATIC_INLINE void hi_cpu_attach(hi_cpu_object_t* object, hi_cpu_object_t* parent) {
	hi_obj_attach((hi_object_header_t*) &object->hdr,
				  (hi_object_header_t*) &parent->hdr);
}
STATIC_INLINE void hi_cpu_detach(hi_cpu_object_t* object, hi_cpu_object_t* parent) {
	hi_obj_detach((hi_object_header_t*) &object->hdr,
				  (hi_object_header_t*) &parent->hdr);
}

/**
 * Find cpu object by it's name
 *
 * @param name - name of CPU object
 * 
 * @return cpu object descriptor or NULL if it wasn't found
 * 
 * @see hi_cpu_find_byid
 * */
STATIC_INLINE hi_cpu_object_t* hi_cpu_find(const char* name) {
	return   (hi_cpu_object_t*)	hi_obj_find(HI_SUBSYS_CPU, name);
}

void* hi_cpu_find_byid(hi_cpu_object_t* parent, hi_cpu_objtype_t type, int id);

STATIC_INLINE list_head_t* hi_cpu_list(boolean_t reprobe) {
	return hi_obj_list(HI_SUBSYS_CPU, reprobe);
}

/**
 * Returns total count of Strands, Cores or memory available to system
 */
LIBEXPORT int hi_cpu_num_cpus(void);
LIBEXPORT int hi_cpu_num_cores(void);
LIBEXPORT size_t hi_cpu_mem_total(void);

LIBEXPORT int hi_cpu_mask(hi_cpu_object_t* object, cpumask_t* mask);

tsobj_node_t* tsobj_hi_cpu_format(struct hi_object_header* obj);

#endif /* CPUINFO_H_ */

